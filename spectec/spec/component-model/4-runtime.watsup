;; 4.2 Components

var gamma : context
var s : store
var s' : store 
var s_n : store
var defs : definition*
var component_inst_n : component_inst

syntax import_env = name -> externval

relation Reduce: context |- import_env, component_inst | store, component ~> store, component_inst

rule Reduce/component:
  gamma |- import_env, component_inst | s, def ~> s_n, component_inst_n


;; 4.2.1 Definitions

relation Reduce_def: context |- import_env | store, component_inst, definition ~> store, component_inst


;; Core Modules

rule Reduce_def/core_module:
  gamma |- import_env | s, component_inst, CORE_MODULE core_module ~> s, component_inst (+) { CORE_MODULES core_module } 


;; Core Instances

rule Reduce_def/core_inst_instantiate:
  gamma |- import_env | s, component_inst, CORE_INSTANCE INSTANTIATE core_moduleidx core_instantiatearg* 
  ~> s', component_inst (+) { CORE_INSTANCES core_moduleinst }
  -- $core_module_instantiate(s, component_inst.CORE_MODULES[core_moduleidx], core_instantiatearg*) = (s', core_moduleinst)

rule Reduce_def/core_inst_exports:
  gamma |- import_env | s, component_inst, CORE_INSTANCE EXPORTS core_export*
  ~> s, component_inst (+) { CORE_INSTANCES {component_inst}}


;; Core Types

rule Reduce_def/core_type:
  gamma |- import_env | s, component_inst, CORE_TYPE core_deftype ~> s, component_inst


;; Components

rule Reduce_def/components:
  gamma |- import_env | s, component_inst, COMPONENT component 
  ~> s, component_inst (+) { COMPONENTS (gamma, component_inst, component) }


;; Instances

var component_inst' : component_inst
var gamma' : context

rule Reduce_def/instance_instantiate:
  gamma |- impot_env | s, component_inst, INSTANCE INSTANTIATE componentidx instantiatearg*
  ~> s', component_inst (+) { INSTNACES component_inst' }
  -- if component_inst.COMPOENTS[componentidx] = (gamma', component_inst', component)

;; todo : need relation here...


rule Reduce_def/instance_exports:
  gamma |- import_env | s, component_inst, INSTANCE EXPORTS exports*
  ~> s, component_inst (+) { INSTANCES component_inst' }


;; Aliases

rule Reduce_def/alias:
  gamma |- import_env | s, component_inst, ALIAS { SORT sort, TARGET EXPORT instanceidx name }
  ~> s, component_inst (+) export_inst_i.value
  -- if component_inst.INSTANCES[instanceidx].EXPORTS = export_inst_i*   
  -- if export_inst_i.NAME = name

rule Reduce_def/alias_core_export:
  gamma |- import_env | s, component_inst, ALIAS { SORT sort, TARGET CORE_EXPORT instanceidx name}
  ~> s, component_inst (+) { CORE component_inst.CORE (+) core_exportinst_i.value}    
  -- if compponent_inst.CORE_INSTANCES[instnaceidx].EXPORTS = core_exportinst_i*
  -- core_exportinst_i.NAME = name
 
var u32_o : U32
var u32_i : U32

rule Reduce_def/alias_core_outer:
  gamma |- import_env | s, component_inst, ALIAS { SORT sort, TARGET OUTER u32_o u32i }
  ~> s, component_inst (+) { SORT $index_space(component_inst.PARENT[u32_o], sort)[u32_i] }


;; Types

rule Reduce_def/type:
  gamma |- import_env | s, component_inst, TYPE deftype ~> s, component_inst


;; Import

rule Reduce_def/import:
  gamma |- import_env | s, component_inst, IMPORT { NAME name, DESC externdesc } 
  ~> s, component_inst (+) import_env(name)


;; EXPORTS

rule Reduce_def/export:
  gamma |- import_env | s, compoent_inst, EXPORT { NAME name, DEF sortidx }
  ~> s, component_inst (+) { EXPORTS { NAME name, VALUE component_inst[sortidx] } }

;; todo : here something strange...



;; Canon lift

rule Reduce_def/lift:
  gamma |- import_env | s, component_inst, LIFT core_funcidx canonopt* typeidx 
  ~> s'(+) { CORE_FUNCS 
              { CORE_TYPE $canon_lower_type(gamma[funcidx], canonopt*), 
                CORE_MODULE core_module,
                CORE_CODE {CORE_LOCALS locals, CORE_BODY core_expr}
              }
            }, component_inst (+) {FUNCS ||S.core_funcs||}
  -- s', core_module, locals, core_expr = $up(gamma[typeidx], canonopt*, s, component_inst, core_funcidx) 

;; Canon lower

rule Reduce_def/lower:
  gamma |- import_env | s, component_inst, LOWER funcidx canonopt* typeidx 
  ~> s'(+) { CORE_FUNCS 
             { CORE_TYPE $canon_lower_type(gamma[funcidx], canonopt*), 
               CORE_MODULE core_module,
               CORE_CODE {CORE_LOCALS locals, CORE_BODY core_expr}
             }
           }, component_inst (+) {CORE_FUNCS ||S.core_funcs||} 
  -- s', core_module, locals, core_expr = $down(gamma[funcidx], canonopt*, s, component_inst, funcidx)

;; Canon resource.new

rule Reduce_def/resource.new:
  gamma |- component_inst, (RESOURCE.NEW typeidx)(i32)
  ~> s', ||s.INSTANCES[component_inst.STATE].HANDLES[deftype_e]
  -- deftype_e = gamma.TYPES[typeidx]
  -- s' = s (+) {s.INSTANCES[component_inst.STATE].HANDLES[deftype_e] ||s.HANDLES||, HANDLES {REP i32, OWN TRUE}}

;; Canon resource.drop
;; todo : spec's rule seems to be errorneous...

;; Canon resource.rep

rule Reduce_def/resource.rep:
  gamma |- s, component_inst, (RESOURCE.REP typeidx)(i32)
  ~> s,
  s.HANDLES[s.INSTANCES[component_inst.STATE].HANDLES[gamma.TYPES[typeidx]][i32]].REP


